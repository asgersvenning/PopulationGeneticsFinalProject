---
title: "Exploratory Analysis"
author: "Asger Svenning"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    toc: true
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(magrittr)
library(tidyverse) %>% 
  suppressPackageStartupMessages()
library(ggforce)
library(patchwork)
library(ggnewscale)
library(extrafont)
library(ggpubr)
library(ggtext)
library(ggrepel)
library(kableExtra)
library(bit)
library(progress)
library(conflicted)
library(ggraph)
library(tidygraph)
library(ape)
c("symdiff", "xor") %>% 
  sapply(function(x) conflict_prefer(x, "bit", quiet = T)) %>% 
  invisible()
c("group_rows", "filter", "select", "lag") %>% 
  sapply(function(x) conflict_prefer(x, "dplyr", quiet = T)) %>% 
  invisible()
c("set_names", "set_colnames", "set_rownames", "extract") %>% 
  sapply(function(x) conflict_prefer(x, "magrittr", quiet = T)) %>% 
  invisible()
c("expand", "pack", "unpack") %>% 
  sapply(function(x) conflict_prefer(x, "tidyr", quiet = T)) %>% 
  invisible()

source("IOUHelpers.R")
source("implicit_iou.R")
source("miscHelpers.R")

knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE,
  eval = F,
  fig.width = 8, 
  fig.height = 8, 
  cache = T, 
  dev.args = list(png = list(type = "cairo"))
)

theme_set(
  theme_pubr(legend = "right", base_family = "CMU Serif") +
    theme(title = element_text(face = "bold",
                               size = 14),
          legend.title = element_text(hjust = .5),
          strip.text = element_text(face = "bold",
                                    size = 14),
          plot.title = element_text(face = "plain",
                                    size = 20,
                                    hjust = .5),
          aspect.ratio = 1)
)
```

# Hyperparameters
```{r hyperParams}
precomputed <- T

segment_type <- "all" %>% 
  tolower %>% 
  pmatch(c("altai", "denisova"   , "vindija", 
           "known", "neanderthal", "unknown", 
           "all"  , "altai_denisova", "epas1"))

file_suffix <- c("_altai", 
                 "_denisova", 
                 "_vindija", 
                 "_known", 
                 "_neanderthal", 
                 "_unknown", 
                 "", 
                 "_altaidenisova",
                 "_epas1")[segment_type]

figure_annotation <- str_remove(file_suffix, "^_") %>% 
  str_replace("_", " & ") %>% 
  tools::toTitleCase()

if (figure_annotation == "Epas1") figure_annotation <- "EPAS1"


precomputed <- if (precomputed != "force") file.exists(paste0("all_dmat", file_suffix, ".rds")) & precomputed else F

epas1 <- F
if (segment_type == 4) {
  segment_type <- 1:3
} else if (segment_type == 5) {
  segment_type <- c(1,3)
} else if (segment_type == 6) {
  segment_type <- 0
} else if (segment_type == 7) {
  segment_type <- 0:3
} else if (segment_type == 8) {
  segment_type <- 1:2
} else if (segment_type == 9) {
  segment_type <- 0:3
  epas1 <- T
}

chromosome <- "all"
if (length(chromosome) == 1 && chromosome == "all") {
  chromosome <- c(1:22, "X")
} else if (is.numeric(chromosome)) {
  chromosome <- as.character(chromosome)
}

downscale <- if (!epas1) 1000 else 1

source("prepareArchaicData.R")
```


# Import data
Filter lengths for positive lengths, since negative lengths are impossible. Negative lengths are probably present due to underflow in the bioinformatics pipeline prior to this analysis.

```{r totalArchaicLength}
arch_length_tot_plt <- arch %>% 
  mutate(
    region = if (!epas1) region else {
      ifelse(country == "Tibet", "Tibet", region) %>% 
        factor(c(sort(unique(region)), "Tibet"))
    }
  ) %>% 
  group_by(name, region) %>% 
  summarize(
    tot_len = sum(length)
  ) %>% 
  ggplot(aes(tot_len / ifelse(epas1, 10^3, 10^6), fill = region)) +
  geom_histogram(
    aes(color = after_scale(fill)),
    bins = if (!epas1) 100 else 25,
    key_glyph = draw_key_point
  ) +
  scale_fill_brewer(palette = "Dark2") +
  scale_x_continuous(
    labels = function(x) prettify_scientific(format(x, scientific = F)),
    breaks = if (!epas1) seq(0, 1000, 10) else seq(0, 1000, 50)
  ) +
  coord_cartesian(expand = F) +
  guides(fill = guide_legend(
    override.aes = list(shape = 21,
                        size = 5))) +
  theme(
    aspect.ratio = .5,
    legend.position = c(.75,.75),
    legend.box.background = element_rect(colour = "black", 
                                         linewidth = .5, 
                                         linetype = "solid"),
    legend.box.margin = margin(1,1,1,1),
    axis.text.x = if (epas1) element_text() else element_text(size = 10)
  ) +
  labs(x = if (epas1) "Total Archaic Segment Length (in thousands, K)" else "Total Archaic Segment Length (in millions, M)", y = NULL, fill = NULL)

ggsave(paste0("arch_length_total", file_suffix, ".pdf"), align_legend(arch_length_tot_plt),
       device = cairo_pdf,
       width = 8, height = 4, scale = 1.25)
```


## Segment Ancestry by population
```{r, eval=TRUE}
arch_raw %>% 
  count(pop, primary_ancestry) %>% 
  group_by(pop) %>% 
  mutate(
    n = n / sum(n),
    n = scales::label_percent(.1)(n)
  ) %>% 
  ungroup %>% 
  mutate(
    primary_ancestry = c("Unknown", "Altai", "Denisova", "Vindija")[primary_ancestry + 1]
  ) %>% 
  pivot_wider(
    id_cols = pop,
    names_from = primary_ancestry,
    values_from = n
  ) %>% 
  rename("Population" = "pop") %>%
  kable("latex",
        align = "rcccc") %>% 
  kable_material(
    latex_options = c("striped", "HOLD_position"),
    full_width = F
  ) %>% 
  add_header_above(c("", "Proportion of Archaic Segments of Ancestry from:" = 4)) %>% 
  write_lines("archaicAncestryPop.txt")
```


## Which populations are overrepresented
```{r popRepresent, eval=TRUE}
arch %>% 
  distinct(name, pop) %>%
  count(pop) %>% 
  arrange(desc(n)) %>% 
  slice_head(n = 5) %>% 
  rename("Population" = "pop", "No. Individuals" = "n") %>%
  kable("latex",
        align = "rc") %>% 
  kable_material(latex_options = c("striped", "HOLD_position"),
                 full_width = F) %>% 
  write_lines("noIndividInPop.txt")
```

# Questions

## To what extent do individuals share SNPs contributed by archaic human introgression? In other words, how correlated are the archaic contents in two individuals?

In order to do this analyses we first check if the segments align, which would simplify the analyses significantly.
```{r segmentViz, fig.height=8, fig.width=16}
arch_segment_plt <- arch %>%
  filter(chrom == ifelse(epas1, "2", "10") & !(is.na(start) & epas1)) %>%
  mutate(
    # Shared_with_Neanderthal = pmin(1, Shared_with_Altai / snps)
    AltaiDenisova = Shared_with_Altai / Shared_with_Denisova
    # propDenisova = Shared_with_Denisova / snps
  ) %>% 
  arrange(region) %>% 
  mutate(name = as.integer(factor(name, unique(name))),
         region = factor(region)) %>%
  group_by(name) %>%
  arrange(start) %>% 
  mutate(first = row_number() == 1) %>% 
  ungroup %>% 
  ggplot(aes(xmin = start, 
             xmax = end, 
             ymin = name, 
             ymax = name + 1,
             fill = MeanProb)) +
  
  geom_rect(
    linewidth = 0
  ) +
  
  scale_fill_viridis_c(
    option = "A",
    direction = 1,
    # name = "Altai / Denisova",
    name = "Probability\nof\nArchaic Ancestry",
    limits = c(0, 1),
    breaks = seq(0, 1, .1),
    labels = scales::label_percent(),
    guide = guide_colorbar(
      barheight = unit(15, "lines"),
      barwidth = unit(3, "lines"),
      
    )
  ) +
  
  new_scale_fill() +
  
  geom_rect(
    aes(xmin = ifelse(start, min(start, na.rm = T), NA) - 10^5, 
        xmax = min(start),
        fill = region,
        color = after_scale(fill)),
    key_glyph = draw_key_point,
    linewidth = .3,
  ) +
  
  scale_fill_brewer(
    palette = "Dark2", 
    name = "Geographic\nRegion",
    guide = guide_legend(
    override.aes = list(shape = 21,
                        size = 10))
  ) +
  
  scale_x_continuous(
    labels = prettify_scientific,
    n.breaks = 10
  ) +
  coord_cartesian(expand = F) +
  labs(x = "Genomic Position", y = "Individual (not shown)") + 
       # title = if (epas1) "Archaic Segments in a 1Mb window around EPAS1" else "Archaic Segments in Chromosome 10") +
  theme(aspect.ratio = .5,
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.text = element_text(size = 12),
        title = element_text(size = 18),
        plot.title = element_text(size = 32),
        panel.background = element_rect(fill = "#000004FF")
        )

if (epas1) {
  epas_nindiv <- arch %>%
    filter(chrom == ifelse(epas1, "2", "10") & !(is.na(start) & epas1)) %>% 
    pull(name) %>% 
    unique %>% 
    length
  
  arch_segment_plt <- arch_segment_plt + 
    geom_vline(xintercept = c(46293667, 46386697),
               color = "red") +
    annotate(
      "rect", xmin = 46293667, xmax = 46386697,
      ymin = 1, ymax = epas_nindiv,
      fill = "#FF000033"
    )
}

ggsave(paste0("arch_segment", file_suffix, ".pdf"), align_legend(arch_segment_plt),
       device = cairo_pdf,
       width = 8, height = 3.75, scale = 2)
```

Since the segments do not overlap we have to somehow efficiently measure their degree of similarity, the most naÃ¯ve method would be to index would be a distance metric calculated between binary vectors of archaic/modern state for each position in e.g. a chromosome. An intuitive similarity measure between such vectors would be the intersection over union, also called the Jaccard Index, both of these have a complementary dissimilarity measure:

$$d_\mathrm{J}(\mathbf{x},\mathbf{y})=d_{\mathrm{IoU}}(\mathbf{x},\mathbf{y})=1 - \frac{\sum_{i=0}^{|\mathbf{x}|}\mathbf{1}_{x_i = 1\;\land\; y_i = 1}}{\sum_{i=0}^{|\mathbf{x}|}\mathbf{1}_{x_i = 1\;\lor\; y_i = 1}},\quad |\mathbf{x}| = |\mathbf{y}|$$
This distance can be readily interpreted as 1 minus the proportion of shared archaic state out of the maximum possible given the two individuals in question.
This distance is chosen due to it's interpretability and since it can be efficiently calculated using bitwise boolean operations (much much faster than explicitly computing the intersections and union). However we will still expect this to be prohibitive due to the memory footprint of binary vectors the size of the human genome. We therefore opt to approximate the binary archaic state vectors by dividing the indices of the archaic fragments by a relatively large constant (400) and rounding it. By doing this we are able to reduce the memory usage by several orders of magnitude while not sacrificing much in terms of precision. 
It is however very important to consider the way in which the indices are rounded after division, to ensure that the calculated distances are unbiased and low-variance. This will be explored in the following section.

# Comparison of suggested methods for efficient unbiased approximation of $d_{\mathrm{IoU}}$
I suggest six rather straight-forward rounding methods:

1) Ceiling
2) Floor
3) Round
4) Random
5) Expand
6) Contract

the first three are perhabs the most naÃ¯ve; "Ceiling", "Floor" and "Round". In these three methods we simply round both the start and end indices the same way: either up, down or to the closest integer. The next three methods are slightly more complicated. 

In the "Random" method I still use the same method on both the start and end index. First the number is split into it's integer, $x_Z$, and decimal, $X_R$, parts and then the decimal part is sampled as a Bernoulli variable, and the final rounded number, $X_{\mathrm{round}}$ is then the sum of these such that: $X_{\mathrm{round}} \sim X_Z+\mathrm{B}(1,X_R)$. 

The last two methods treat the start and end indices differently:
The "Expand" method <i>expands</i> the rounded intervals by rounding the start index down and the end index up. The "Contract" method <i>contracts</i> the rounded intervals by doing the opposite of the "Expand" method; rounding the start index up and the end index down. 

I evaluate these different methods by randomly selecting two individuals and extracting their archaic segments in chromosome 3 (arbitrarily). I then calculate $d_{\mathrm{IoU}}$ for increasingly downscaled representations (approximations) of the archaic segments:

\begin{figure}
  \includegraphics[width=\textwidth]{approxError_zoom.pdf}
\end{figure}

# Analyses

## Prepare data
Before doing analyses, I offset the genomic positions of the segments such that the indices in each chromosome start after the end of the previous chromosome 

I then combine all segments in each individual into a pseudo-class which is essentially a custom data structure, such that I can use custom-made functions that work on said data structure.
Now that the data is prepared in a suitable data structure I can perform my analyses.


## Pairwise $d_\mathrm{IoU}$
I then move on to using the full pairwise distance matrix, this would not be feasible without the explained optimizations. However using the methods described this can be done in a matter of seconds-to-minutes.

```{r}
iou_hist <- all_dmat %>% 
  mutate(
    prs_1 = factor(prs_1),
    prs_2 = factor(prs_2, levels(prs_1))
  ) %>% 
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  mutate(
    region_type = ifelse(region_1 == region_2, region_1, "between"),
    region_type = factor(region_type, c(sort(unique(region_1)), "between"))
  ) %>% 
  ggplot(aes(1 - iou#, 
             # fill = region_type,
             # color = after_scale(fill)
             )) +
  geom_histogram(colour = "gray35") +
  # stat_bin(bins = 50,
  #            # linewidth = 0.1,
  #            position = "identity",
  #            key_glyph = draw_key_point,
  #            geom = "col") +
  # scale_fill_brewer(palette = "Dark2") +
  scale_y_log10(n.breaks = 10,
                labels = prettify_scientific) +
  scale_x_continuous(labels = scales::label_percent()) +
  coord_cartesian(expand = F, xlim = c(0, 1)) +
  labs(x = "Intersection over Union", y = NULL) +
  guides(
    fill = guide_legend(
      override.aes = list(
        shape = 16,
        size = 5
      ),
      ncol = 3
    )
  ) +
  theme(aspect.ratio = .33,
        panel.grid.major.y = element_line(colour = "gray80", linetype = "dashed", linewidth = .5),
        # plot.margin = margin(1),
        legend.title = element_blank(),
        legend.text = element_text(size = 8),
        legend.box.background = element_rect(colour = "black", linetype = "solid", linewidth = 1),
        legend.position = c(.625, .725),
        plot.margin = margin(2, 5, 0, 0, "mm"))

ggsave(paste0("iou_hist", file_suffix, ".pdf"), iou_hist,
       device = cairo_pdf, antialias = "subpixel",
       width = 4, height = 1.5, dpi = 400, scale = 1.5)
```


And the full pairwise $d_\mathrm{IoU}$ matrix is computed in only `r time_used[3]` seconds. The distance matrix is visualized below:

```{r allPairDMat, fig.width = 12, fig.height = 12}
# person to country "dictonary" / map
prs_to_country <- all_dmat %>% 
  distinct(country_1, prs_1) %>% 
  {set_names(.$country_1, .$prs_1)}

# Create heatmap of the entire pairwise dIoU matrix
all_dmat_plt <- all_dmat %>%
  filter(!epas1 | (prs_1 %in% epas_set & prs_2 %in% epas_set)) %>% 
  # Ensure that individuals are ordered by region and country in the plot
  arrange(region_1, region_2, country_1, country_2, pop_1, pop_2, prs_1, prs_2) %>%  
  mutate(
    across(contains("_1"), 
           ~ factor(.x, unique(.x))),
    across(contains("_2"), 
           ~ factor(.x, levels(unlist(pick(paste0(str_extract(cur_column(), ".+(?=_[12]$)"), "_1")))))),
    country_fill_1 = RColorBrewer::brewer.pal(5, "Dark2")[as.integer(region_1)],
    country_fill_2 = RColorBrewer::brewer.pal(5, "Dark2")[as.integer(region_2)],
    country_fill_1 = ifelse(as.integer(country_1) %% 2 == 1, colorspace::lighten(country_fill_1, .5), country_fill_1),
    country_fill_2 = ifelse(as.integer(country_2) %% 2 == 1, colorspace::lighten(country_fill_2, .5), country_fill_2)
  ) %>% 
  # Remove diagonal
  mutate(iou = ifelse(prs_1 == prs_2, NA, iou)) %>% 
  ggplot() +
  # dIoU heatmap tiles
  geom_tile(
    aes(x = prs_1, 
        y = prs_2, 
        fill = iou,
        color = iou),
    # linewidth = 0
  ) +
  # dIoU color map
  scale_fill_viridis_c(
    option = "A",
    direction = -1,
    na.value = "gray75",
    labels = scales::label_percent(),
    name = latex2exp::TeX("$d_{IoU}$")) +
  scale_color_viridis_c(
    option = "A",
    direction = -1,
    na.value = "gray75",
    guide = "none") +
  # Reset color map
  new_scale_fill() +
  # Country axis annotations
  geom_tile(
    aes(x = -4.5, 
        y = ifelse(as.integer(prs_1) == 1, prs_2, NA), 
        fill = country_fill_2,
        color = after_scale(fill)),
    linewidth = 0,
    width = 10,
    show.legend = F
  ) +
  geom_tile(
    aes(y = -4.5, 
        x = ifelse(as.integer(prs_2) == 1, prs_1, NA), 
        fill = country_fill_1,
        color = after_scale(fill)),
    linewidth = 0,
    height = 10,
    show.legend = F
  ) +
  # Country color indicators
  scale_fill_identity() +
  scale_x_discrete(
    labels = function(x) str_remove(label_grouped_axis(map = prs_to_country, 10)(x), "\\(.+"), 
    expand = expansion(0, c(10, 0))) +
  scale_y_discrete(
    labels = function(x) str_remove(label_grouped_axis(map = prs_to_country, 10)(x), "\\(.+"),
    expand = expansion(0, c(10, 0))) +
  # Ensure that distance matrix is square
  coord_equal() +
  # Styling
  theme(
    axis.ticks = element_blank(),
    axis.text.x = element_text(hjust = 1,
                               angle = 90,
                               vjust = .1),
    axis.text.y = element_text(vjust = .1),
    axis.text = element_text(size = 8),
    axis.title = element_blank(),
    legend.title = element_text(hjust = .5,
                                size = 20),
    legend.text = element_text(size = 14),
    legend.key.width = unit(2, "lines"),
    legend.key.height = unit(4, "lines")
  )

# all_dmat_plt
ggsave(paste0("all_dmat", file_suffix, ".pdf"), align_legend(all_dmat_plt),
       device = cairo_pdf, antialias = "subpixel",
       width = 8, height = 7, dpi = 300, scale = 1)
# all_dmat_plt
```
\begin{figure}
  \includegraphics[width=\textwidth]{all_dmat.pdf}
\end{figure}


The distance matrix can be summarized for:

## Within population variation
The first analysis I perform is an investigation into the within-population shared archaic ancestry.
```{r withinPopDIoU}
# Helper function for calculating the side length of a lower triangle from its area:
#   y = x^2/2 -x/2 
#   -> 1/2 x^2 - 1/2 x - y 
#   -> x = (1/2 +/- sqrt(1/4 - 4 * 1/2 * -y))/(2 * 1/2)
#   -> x = 1/2 +/- sqrt(1/4 + 2y)
#   -> x = 1/2 + sqrt(1/4 + 2y)
lower_tri_base_width <- function(area) 1/2 + sqrt(1/4 + 2 * area)

within_pop_iou <- all_dmat %>% 
  # Filter only comparisons within populations
  # filter(pop_1 == pop_2) %>% 
  mutate(
    prs_1 = factor(prs_1),
    prs_2 = factor(prs_2, levels(prs_1)),
    pop_1 = ifelse(pop_1 == pop_2, pop_1, "Between"),
    region_1 = factor(ifelse(pop_1 == "Between", "Between", region_1), c(sort(unique(region_1)), "Between"))
  ) %>% 
  # Filter lower triangle of pairwise dIoU matrix
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  rename("region" = "region_1", "country" = "country_1", "pop" = "pop_1") %>% 
  group_by(pop) %>% 
  # filter(sum(!is.na(iou)) > 2) %>% 
  # (Stupid) way to calculate number of individuals, 
  # could be replaced by length(unique(c(prs_1,prs_2)))
  # mutate(n = ifelse(row_number() == 1, n(), NA),
  #        n = lower_tri_base_width(n)) %>% 
  mutate(n = ifelse(row_number() == 1, length(unique(c(prs_1,prs_2))), NA)) %>% 
  ungroup %>% 
  # Sort population by region in plot
  arrange(region, country, pop) %>% 
  mutate(across(c(country, pop), ~factor(.x, unique(.x)))) %>%
  ggplot(aes(x = iou, 
             y = pop, 
             fill = region, 
             label = n)) +
  geom_boxplot(
    key_glyph = draw_key_point,
    linewidth = .4,
  ) +
  # geom_violin(
  #   scale = "width",
  #   key_glyph = draw_key_point,
  #   linewidth = .4
  # ) +
  # Individual count labels for populations
  geom_text(
    aes(x = 1),
    hjust = 1,
    vjust = .5,
    position = position_nudge(x = .035),
    fontface = "bold",
    family = "CMU Serif",
    size = 4
  ) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_fill_brewer(palette = "Dark2") +
  # Styling
  guides(
    fill = guide_legend(
      override.aes = list(shape = 21,
                          size = 7,
                          stroke = 1)
    )
  ) +
  coord_cartesian(
    clip = "off",
    expand = F,
    xlim = 0:1
  ) +
  labs(
    x = latex2exp::TeX("$d_{IoU}$"),
    y = NULL,
    fill = "Geographical\nRegion"
  ) +
  theme(
    legend.text = element_text(size = 11),
    axis.text.y = element_text(hjust = 0),
    axis.title.x = element_text(margin = margin(1, 0, 0, 0, "lines")),
    axis.ticks = element_blank(),
    title = element_text(size = 16),
    panel.grid.major.y = element_line(colour = "gray75", linewidth = .25, linetype = "dashed"),
    legend.box.margin = margin(1,1,1,1, "lines"),
    legend.box.background = element_rect(colour = "black", linetype = "solid", linewidth = .55),
    aspect.ratio = 1.5,
    legend.position = c(.2, .875),
    plot.margin = margin(0,30,0,0)
  )

ggsave(paste0("within_pop_iou", file_suffix, ".pdf"), align_legend(within_pop_iou),
       device = cairo_pdf,
       width = 4.75, height = 6.25, scale = 2.5)
```


```{r withinCountryDIoU}
within_country_iou <- all_dmat %>% 
  # Filter only comparisons within populations
  # filter(country_1 == country_2) %>% 
  mutate(
    prs_1 = factor(prs_1),
    prs_2 = factor(prs_2, levels(prs_1)),
    country_1 = factor(ifelse(country_1 == country_2, country_1, "Between"), c(sort(unique(country_1)), "Between")),
    region_1 = factor(ifelse(country_1 == "Between", "Between", region_1), c(sort(unique(region_1)), "Between"))
  ) %>% 
  # Filter lower triangle of pairwise dIoU matrix
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  rename("region" = "region_1", "country" = "country_1", "pop" = "pop_1") %>% 
  group_by(country) %>% 
  # filter(sum(!is.na(iou)) > 2) %>% 
  # (Stupid) way to calculate number of individuals, 
  # could be replaced by length(unique(c(prs_1,prs_2)))
  # mutate(n = ifelse(row_number() == 1, n(), NA),
  #        n = lower_tri_base_width(n)) %>% 
  mutate(n = ifelse(row_number() == 1, length(unique(c(prs_1,prs_2))), NA)) %>% 
  ungroup %>% 
  # Sort population by region in plot
  arrange(region, country, pop) %>% 
  mutate(across(c(country, pop), ~factor(.x, unique(.x)))) %>%
  ggplot(aes(x = iou, 
             y = country, 
             fill = region, 
             label = n)) +
    geom_boxplot(
    key_glyph = draw_key_point,
    linewidth = .4,
  ) +
  # geom_violin(
  #   scale = "width",
  #   key_glyph = draw_key_point
  # ) +
  # Individual count labels for populations
  geom_text(
    aes(x = 1),
    hjust = 1,
    vjust = .5,
    position = position_nudge(x = .035),
    fontface = "bold",
    family = "CMU Serif",
    size = 4
  ) +
  scale_x_continuous(labels = scales::label_percent()) +
  scale_fill_brewer(palette = "Dark2") +
  # Styling
  guides(
    fill = guide_legend(
      override.aes = list(shape = 21,
                          size = 7,
                          stroke = 1)
    )
  ) +
  coord_cartesian(
    clip = "off",
    expand = F,
    xlim = 0:1
  ) +
  labs(
    x = latex2exp::TeX("$d_{IoU}$"),
    y = NULL,
    fill = "Geographical\nRegion"
  ) +
  theme(
    legend.text = element_text(size = 11),
    axis.text.y = element_text(hjust = 0),
    axis.title.x = element_text(margin = margin(1, 0, 0, 0, "lines")),
    axis.ticks = element_blank(),
    title = element_text(size = 16),
    panel.grid.major.y = element_line(colour = "gray75", linewidth = .25, linetype = "dashed"),
    legend.box.margin = margin(1,1,1,1, "lines"),
    legend.box.background = element_rect(colour = "black", linetype = "solid", linewidth = .55),
    aspect.ratio = .7,
    legend.position = c(.25, .75),
    plot.margin = margin(0,30,0,0)
  )

ggsave(paste0("within_country_iou", file_suffix, ".pdf"), align_legend(within_country_iou),
       device = cairo_pdf,
       width = 4.5, height = 2.8, scale = 2.5)
```

```{r withinCountryDIoU}
within_region_iou <- all_dmat %>% 
  # Filter only comparisons within populations
  # filter(region_1 == region_2) %>% 
  mutate(
    prs_1 = factor(prs_1),
    prs_2 = factor(prs_2, levels(prs_1)),
    region_1 = factor(ifelse(region_1 == region_2, region_1, "Between"), c(sort(unique(region_1)), "Between"))
  ) %>% 
  # Filter lower triangle of pairwise dIoU matrix
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  rename("region" = "region_1", "country" = "country_1", "pop" = "pop_1") %>% 
  group_by(region) %>% 
  # filter(sum(!is.na(iou)) > 2) %>% 
  # (Stupid) way to calculate number of individuals, 
  # could be replaced by length(unique(c(prs_1,prs_2)))
  # mutate(n = ifelse(row_number() == 1, n(), NA),
  #        n = lower_tri_base_width(n)) %>% 
  mutate(n = ifelse(row_number() == 1, length(unique(c(prs_1,prs_2))), NA)) %>% 
  ungroup %>% 
  # Sort population by region in plot
  arrange(region, country, pop) %>% 
  mutate(across(c(country, pop), ~factor(.x, unique(.x)))) %>%
  ggplot(aes(x = iou, 
             y = region, 
             fill = region, 
             label = n)) +
  # geom_boxplot(
  #   key_glyph = draw_key_point,
  #   linewidth = .4,
  # ) +
  geom_violin(
    scale = "width",
    key_glyph = draw_key_point
  ) +
  # Individual count labels for populations
  geom_text(
    aes(x = 1),
    hjust = 1,
    vjust = .5,
    # adjust = .1,
    position = position_nudge(x = -0.065),
    fontface = "bold",
    family = "CMU Serif",
    size = 4
  ) +
  scale_x_continuous(labels = Vectorize(function(x) if (is.na(x)) "" else scales::label_percent()(x))(
    c(0, NA, NA, .3, NA, NA, .6, .7, .8, .9, 1)
  ),
                     expand = expansion(),
                     trans = invlog(10, .1, 1),
                     breaks = seq(0, 1, .1),) +
  scale_y_discrete(expand = expansion(0, .5)) +
  scale_fill_brewer(palette = "Dark2") +
  # Styling
  guides(
    fill = guide_legend(
      override.aes = list(shape = 21,
                          size = 7,
                          stroke = 1)
    )
  ) +
  coord_cartesian(
    clip = "off",
    xlim = 0:1
  ) +
  labs(
    x = latex2exp::TeX("$d_{IoU}$"),
    y = NULL,
    fill = "Geographical\nRegion"
  ) +
  theme(
    legend.text = element_text(size = 11),
    axis.text.y = element_text(hjust = 0),
    axis.title.x = element_text(margin = margin(1, 0, 0, 0, "lines")),
    axis.ticks.y = element_blank(),
    title = element_text(size = 16),
    panel.grid.major.y = element_line(colour = "gray75", linewidth = .25, linetype = "dashed"),
    legend.box.margin = margin(1,1,1,1, "lines"),
    legend.box.background = element_rect(colour = "black", linetype = "solid", linewidth = .55),
    aspect.ratio = 1,
    legend.position = "none",
    plot.margin = margin(0,20,0,0)
  )

ggsave(paste0("within_region_iou", file_suffix, ".pdf"), within_region_iou,
       device = cairo_pdf,
       width = 3, height = 2.45, scale = 2.5)
```

## Summarized for regions
```{r allPairRegionSum}
# Create a new heatmap of the dIoU matrix, aggregated for each combination of regions
region_dmat <- all_dmat %>% 
  mutate(prs_1 = factor(prs_1),
         prs_2 = factor(prs_2, levels = levels(prs_1))) %>%
  group_by(same_region = region_1 == region_2, region_1, region_2) %>% 
  summarize(
    iou = mean(iou[prs_1 != prs_2], na.rm = T),
    .groups = "drop"
  ) %>%
  ggplot(aes(region_1, region_2, fill = iou)) +
  geom_tile(aes(color = after_scale(fill)),
            linewidth = .001) +
  scale_fill_viridis_c(option = "A",
                       direction = -1) +
  coord_equal(expand = F) +
  labs(fill = latex2exp::TeX("$d_{IoU}$")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank(),
        legend.title = element_text(hjust = .5,
                                    size = 20),
        legend.text = element_text(size = 14),
        legend.key.width = unit(2, "lines"),
        legend.key.height = unit(4, "lines"))

ggsave(paste0("region_dmat", file_suffix, ".pdf"), align_legend(region_dmat),
       device = cairo_pdf,
       width = 4, height = 4, scale = 2.5)
# region_dmat
```
\begin{figure}
  \includegraphics[width=\textwidth]{region_dmat.pdf}
\end{figure}
and:

## Summarized for countries
```{r allPairCountrySum}
# Create a new heatmap of the dIoU matrix, aggregated for each combination of countries
country_dmat <- all_dmat %>% 
  arrange(region_1) %>% 
  mutate(prs_1 = factor(prs_1),
         prs_2 = factor(prs_2, levels = levels(prs_1)),
         country_1 = factor(country_1, unique(country_1)),
         country_2 = factor(country_2, levels(country_1))) %>%
  group_by(same_country = country_1 == country_2, country_1, country_2) %>% 
  summarize(
    iou = mean(iou[prs_1 != prs_2], na.rm = T),
    .groups = "drop"
  ) %>% 
  complete(country_1, country_2, fill = list(iou = NA)) %>% 
  ggplot(aes(country_1, country_2, fill = iou)) +
  geom_tile(aes(color = after_scale(fill))) +
  scale_fill_viridis_c(option = "A",
                       na.value = "gray75",
                       direction = -1) +
  coord_equal(expand = F) +
  labs(fill = latex2exp::TeX("$d_{IoU}$")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 1),
        axis.title = element_blank(),
        legend.title = element_text(hjust = .5,
                                    size = 20),
        legend.text = element_text(size = 14),
        legend.key.width = unit(2, "lines"),
        legend.key.height = unit(4, "lines"))

ggsave(paste0("country_dmat", file_suffix, ".pdf"), country_dmat,
       device = cairo_pdf,
       width = 4, height = 4, scale = 2.5)
# country_dmat
```
\begin{figure}
  \includegraphics[width=\textwidth]{country_dmat.pdf}
\end{figure}

And also used for post-hoc hierarchical clustering:

## Archaic state "phylogeny"
```{r allPairHierClust, fig.width = 12, fig.height = 12}
# Prepare person metadata
arch_meta <- arch_persons %>% 
  select(name, pop, country, region) %>% 
  arrange(region) %>% 
  mutate(country = factor(country, unique(country)))

# Convert tidy pairwise dIoU matrix to a proper R-matrix
all_t_dmat <- all_dmat %>% 
  arrange(country_1, country_2) %>% 
  mutate(
    prs_1 = factor(prs_1, unique(prs_1)),
    prs_2 = factor(prs_2, levels(prs_1))
  ) %>% 
  select(prs_1, prs_2, iou) %>%
  # Convert to wide-format
  pivot_wider(
    id_cols = prs_1, 
    names_from = prs_2, 
    values_from = iou
  ) %>%
  select(!prs_1) %>% 
  # Convert to matrix
  as.matrix %>% 
  set_rownames(colnames(.)) %>% 
  # Subtract 0.1% quantile 
  subtract(quantile(.[lower.tri(.)], .001, na.rm = T)) %>% 
  # Clamp to zero
  {set_attributes(pmax(., 0), attributes(.))}

# Compute a NJ tree on the dIoU matrix using `ape`
all_tree <-  all_t_dmat %>% 
  njs()

# Find the most divergent individual, used as an outgroup for rooting the NJ tree
most_divergent_individual <- all_t_dmat %>% 
  {
    diag(.) <- NA
    .
  } %>% 
  apply(1, mean, na.rm = T) %>% 
  which.max %>% 
  names

# Root the tree using the above-found outgroup
all_tree_rooted <- all_tree %>% 
  root(most_divergent_individual, resolve.root = T)

# Convert the `ape`-phylo to a `tidygraph`-tbl_graph and re-attach person metadata
all_tree_tidy <- all_tree_rooted  %>% 
  as_tbl_graph() %>%
  mutate(
    leaf = node_is_leaf(),
    root = node_is_root(),
    height = node_distance_to(node_is_root(), "in", weights = length),
    outgroup = name == most_divergent_individual
  ) %>%
  left_join(arch_meta)

# Extract the maximum branch height, used for aligning the tip labels  
max_divergence <- all_tree_tidy %>% 
  filter(leaf) %>% 
  pull(height) %>% 
  max %>% 
  multiply_by(1.05) 

max_divergence <- max_divergence * 1.25

# Plot the NJ-tree using `ggraph`
hier_cluster_dmat <- all_tree_tidy %>% 
  # Scale the branches by length
  ggraph("dendrogram", height = height) +
  # Plot edges as elbows (i.e. vertical-bend-horizontal-merge)
  geom_edge_elbow(edge_width = .25) +
  # Plot the outgroup leaf
  geom_node_point(
    aes(y = ifelse(outgroup,  y, NA)),
    color = "firebrick",
    shape = 16, size = 2) +
  # Create a line from the outgroup leaf to it's corresponding square
  geom_segment(
    aes(y = ifelse(outgroup, y, NA),
        yend = max_divergence * .975,
        x = x,
        xend = x),
    color = "firebrick",
    linetype = "dashed",
    linewidth = .5
  ) +
  # Plot a square above each leaf in a circle, coloured by the population of the leaf
  geom_node_tile(
    aes(fill = country, 
        color = country,
        width = leaf, 
        y = max_divergence + max_divergence / 17.5),
    height = max_divergence / 17.5,
  ) +
  # Plot the name of the population above the squares
  geom_node_text(
    aes(color = country, 
        label = country,
        y = ifelse(leaf, max_divergence + 2 * max_divergence / 22.5, NA), 
        # Annoying text-rotation calculations
        angle = 360 - x * 0.999 + 90 + 177 * ((x * 0.999) > 180),
        # Text-justification has to be different on each side, since the text is flipped
        hjust = (x * 0.999) > 180),
    # Font-size is very small to avoid overlapping text
    size = 2.5
  ) +
  scale_fill_discrete() +
  scale_fill_discrete() +
  ggnewscale::new_scale_fill() +
  ggnewscale::new_scale_colour() +
  # Plot a square above each leaf in a circle, coloured by the region of the leaf
  geom_node_tile(
    aes(fill = region, 
        color = region,
        width = leaf, 
        y = max_divergence),
    height = max_divergence / 17.5,
  ) +
  # Plot the name of the population above the squares
  geom_node_text(
    aes(color = region, 
        label = region,
        y = ifelse(leaf, max_divergence - max_divergence / 25, NA), 
        # Annoying text-rotation calculations
        angle = 360 - x * 0.999 + 90 + 177 * ((x * 0.999) > 180),
        # Text-justification has to be different on each side, since the text is flipped
        hjust = (x * 0.999) <= 180),
    # Font-size is very small to avoid overlapping text
    size = 2.5
  ) +
  scale_fill_brewer(palette = "Dark2") +
  scale_colour_brewer(palette = "Dark2") +
  # Use polar coordinates; makes the dendrogram circular
  # (I find this easier than using the built-in "circular" option in `ggraph`)
  coord_polar() +
  # Disable axis expansion (not completely necessary)
  scale_x_continuous(expand = expansion()) +
  scale_y_continuous(expand = expansion(), trans = "identity") +
  # Styling
  labs(
    # title = figure_annotation,
    title = latex2exp::TeX("Neighbour-Joining Tree of the Full Pairwise $d_{IoU}$ Matrix"),
    # caption = "<b>OBS:</b><br>* Rooted by using the individual with the lowest mean IoU (i.e. highest dIoU) as outgroup.\n The tip of the outgroup individual is marked by the red circle.<br>** Distances have been renormalized by subtracting the .1% quantile and clamping to 0."
  ) +
  theme(
    legend.position = "none",
    plot.caption = element_textbox_simple(
      face = "plain",
      size = 12,
      hjust = 0,
      color = "black",
      box.color = "black",
      linewidth = .5,
      linetype = "solid",
      fill = "gray85",
      width = unit(40, "lines"),
      padding = margin(1,1,1,1,"lines")
    ),
    plot.title = element_text(size = 32),
    plot.margin = margin(0,-.9,-1.75, -2, "cm")
    # plot.title = element_text(size = 48, hjust = 0.05, vjust = -10, margin = margin()),
    # plot.margin = margin(-2.5,-2,-1,-2, "cm")
  )

ggsave(paste0("hier_cluster_dmat", file_suffix, ".pdf"), hier_cluster_dmat,
       device = cairo_pdf,
       width = 5.75, height = 6.25, scale = 2.5, dpi = 300)
      # theme(legend.position = "bottom")
```
\begin{figure}
  \includegraphics[width=\textwidth]{hier_cluster_dmat.pdf}
\end{figure}

## Low-dimensional ordination of archaic state dissimilarity
The pairwise distance matrix can also be ordinated using e.g. Principal Coordinate Analysis:
```{r allPairOrd}
ord_data <- all_t_dmat %>% 
  {.[!is.na(rowSums(.)), !is.na(colSums(.))]}  %>% 
  cmdscale(k = 4) %>%
  as.data.frame() %>%
  set_colnames(paste0("PCoA", 1:ncol(.))) %>%
  rownames_to_column("prs") %>%
  as_tibble() %>% 
  left_join(arch_meta, by = c(prs = "name")) %>% 
  group_by(country) %>% 
  mutate(label_country = ifelse(row_number() == 1, country, NA),
         label_country = levels(country)[label_country]) %>% 
  ungroup

ord_plt <- ord_data %>% 
  ggplot(aes(.panel_x, .panel_y, color = region)) +
  geom_point(
    size = 2,
    alpha = .5,
    shape = 16
  ) +
  geom_autodensity(
    aes(fill = after_scale(color)),
    linewidth = .75,
    alpha = .25
  ) +
  stat_density2d(
    aes(group = "1", fill = after_stat(ndensity)),
    # colour = "transparent",
    contour = F,
    adjust = c(2,2),
    geom = "raster"
  ) +
  facet_matrix(
    vars(contains("PCoA")),
    layer.diag = 2,
    layer.lower = 3,
    shrink = F
  ) +
  scale_x_continuous(limits = c(-.5, .5), expand = expansion()) +
  scale_y_continuous(limits = c(-.5, .5), expand = expansion()) +
  scale_color_brewer(palette = "Set1") +
  scale_fill_distiller(
    trans = "identity",
    palette = "Oranges",
    direction = 1,
    guide = "none"
  ) +
  labs(color = "Geographical\nRegion") +
  coord_cartesian(expand = F) +
  guides(color = guide_legend(override.aes = list(alpha = 1,
                                                  size = 5))) +
  theme(panel.border = element_rect(fill = "transparent"))

ggsave(paste0("ord_plt", file_suffix, ".pdf"), ord_plt,
       device = cairo_pdf,
       width = 7, height = 6, scale = 2)
```
\begin{figure}
  \includegraphics[width=\textwidth]{ord_plt.pdf}
\end{figure}

<!-- # Correlation between total archaic length and shared length -->
<!-- ```{r lenDIoURelationship} -->
<!-- library(mgcViz) -->
<!-- library(metR) -->

<!-- len_iou_2d_dat <- all_dmat %>%  -->
<!--   rename_with(function(x) str_replace(x, "prs", "name")) %>%  -->
<!--   left_join(arch_persons %>%  -->
<!--               select(name, prs), by = c(name_1 = "name")) %>%  -->
<!--   rename("prs_1" = "prs") %>%  -->
<!--   left_join(arch_persons %>%  -->
<!--               select(name, prs), by = c(name_2 = "name")) %>%  -->
<!--   rename("prs_2" = "prs") %>%  -->
<!--   mutate( -->
<!--     name_1 = factor(name_1), -->
<!--     name_2 = factor(name_2, levels(name_1)) -->
<!--   ) %>%  -->
<!--   filter(name_1 != name_2) %>%  -->
<!--   # filter(as.integer(name_1) > as.integer(name_2)) %>%  -->
<!--   mutate( -->
<!--     across(contains("prs"), ~map_int(.x, function(x) {  -->
<!--       sum(x$end - x$start) -->
<!--     })), -->
<!--     across(where(is.character), factor) -->
<!--     # prs_2 = cut_width(prs_2, 500, 250, dig.lab = 50) -->
<!--   ) -->

<!-- len_iou_dat <- len_iou_2d_dat %>%  -->
<!--   filter(prs_1 >= prs_2) %>%  -->
<!--   distinct(comb = map2_chr(name_1, name_2, function(x, y) { -->
<!--     paste0(sort(c(x,y)), collapse = "|") -->
<!--   }), .keep_all = T) %>%  -->
<!--   select(!comb) %>%  -->
<!--   mutate(iou_max = 1- (pmin(prs_1, prs_2)/pmax(prs_1, prs_2))) %>% -->
<!--   mutate(across(contains("iou"), ~ 1 - .x)) -->



<!-- ggsave(paste0("len_iou", file_suffix, ".pdf"), len_iou_plt, -->
<!--        device = cairo_pdf, -->
<!--        width = 7, height = 6, scale = 2) -->
<!-- ``` -->
<!-- \begin{figure} -->
<!--   \includegraphics[width=\textwidth]{len_iou.pdf} -->
<!-- \end{figure} -->

