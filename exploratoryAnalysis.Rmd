---
title: "Exploratory Analysis"
author: "Asger Svenning"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    toc: true
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(magrittr)
library(tidyverse) %>% 
  suppressPackageStartupMessages()
library(ggforce)
library(patchwork)
library(ggnewscale)
library(extrafont)
library(ggpubr)
library(ggtext)
library(ggrepel)
library(kableExtra)
library(bit)
library(progress)
library(conflicted)
library(ggraph)
library(tidygraph)
c("symdiff", "xor") %>% 
  sapply(function(x) conflict_prefer(x, "bit", quiet = T)) %>% 
  invisible()
c("group_rows", "filter", "select", "lag") %>% 
  sapply(function(x) conflict_prefer(x, "dplyr", quiet = T)) %>% 
  invisible()
c("set_names", "set_colnames", "set_rownames", "extract") %>% 
  sapply(function(x) conflict_prefer(x, "magrittr", quiet = T)) %>% 
  invisible()
c("expand", "pack", "unpack") %>% 
  sapply(function(x) conflict_prefer(x, "tidyr", quiet = T)) %>% 
  invisible()

source("IOUHelpers.R")
source("implicit_iou.R")

knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE, 
  fig.width = 8, 
  fig.height = 8, 
  cache = T, 
  dev.args = list(png = list(type = "cairo"))
)

theme_set(
  theme_pubr(legend = "right", base_family = "CMU Serif") +
    theme(title = element_text(face = "bold",
                               size = 14),
          legend.title = element_text(hjust = .5),
          strip.text = element_text(face = "bold",
                                    size = 14),
          plot.title = element_text(face = "plain",
                                    size = 20,
                                    hjust = .5),
          aspect.ratio = 1)
)

segment_type <- "unknown" %>% 
  pmatch(c("Altai", "Denisova", "Vindija", "all", "neanderthal", "unknown"))
if (segment_type == 4) segment_type <- 1:3
if (segment_type == 5) segment_type <- c(1,3)
if (segment_type == 6) segment_type <- 0
```

# Import data
Filter lengths for positive lengths, since negative lengths are impossible. Negative lengths are probably present due to underflow in the bioinformatics pipeline prior to this analysis.
```{r readData}
arch <- read_delim("ArchaicSegments.txt", delim = "\t") %>% 
  filter(length > 0) %>% 
  mutate(country = str_extract(country, "[\\w ]+")) %>% 
  nest(all = !c(region, country)) %>% 
  group_by(country) %>% 
  mutate(
    country = paste0(country, rep("_", n()), region),
    country = if (n() == 1) str_remove(country, "_.+") else country
  ) %>% 
  ungroup() %>% 
  unnest(all) %>% 
  filter(length > 0) %>% 
  mutate(chrom = factor(chrom, unique(chrom)[order(as.numeric(unique(chrom)))])) %>% 
  mutate(
    primary_ancestry = apply(across(contains("Shared_with")), 1, which.max),
    primary_ancestry = ifelse(rowSums(across(contains("Shared_with"))) < ceiling(snps/2), 0, primary_ancestry)
  ) %>% 
  filter(primary_ancestry %in% segment_type)
```
## Segment Ancestry by population
```{r}
read_delim("ArchaicSegments.txt", delim = "\t") %>% 
  filter(length > 0) %>% 
  mutate(country = str_extract(country, "[\\w ]+")) %>% 
  nest(all = !c(region, country)) %>% 
  group_by(country) %>% 
  mutate(
    country = paste0(country, rep("_", n()), region),
    country = if (n() == 1) str_remove(country, "_.+") else country
  ) %>% 
  ungroup() %>% 
  unnest(all) %>% 
  filter(length > 0) %>% 
  mutate(chrom = factor(chrom, unique(chrom)[order(as.numeric(unique(chrom)))])) %>% 
  mutate(
    primary_ancestry = apply(across(contains("Shared_with")), 1, which.max),
    primary_ancestry = ifelse(rowSums(across(contains("Shared_with"))) < ceiling(snps/2), 0, primary_ancestry)
  ) %>% 
  count(pop, primary_ancestry) %>% 
  group_by(pop) %>% 
  mutate(n = n/sum(n),
         n = scales::label_percent(2)(n)) %>% 
  ungroup %>% 
  mutate(
    primary_ancestry = c("Unknown", "Altai", "Denisova", "Vindija")[primary_ancestry + 1]
  ) %>% 
  pivot_wider(id_cols = pop, names_from = primary_ancestry, values_from = n) %>% 
  kable() %>% 
  kable_material(full_width = F)
```


## Which populations are overrepresented
```{r popRepresent}
arch %>% 
  distinct(name, pop) %>%
  count(pop) %>% 
  arrange(desc(n)) %>% 
  slice_head(n = 5) %>% 
  kable %>% 
  kable_material(full_width = F)
```

# Questions

## To what extent do individuals share SNPs contributed by archaic human introgression? In other words, how correlated are the archaic contents in two individuals?

In order to do this analyses we first check if the segments align, which would simplify the analyses significantly.
```{r segmentViz, fig.height=8, fig.width=16}
arch %>% 
  filter(chrom == "10") %>%
  ggplot(aes(start - length/2, name, width = length)) +
  geom_tile(height = 1, fill = "black") +
  scale_fill_viridis_c(trans = "log10", option = "A") +
  scale_x_continuous(labels = prettify_scientific,
                     n.breaks = 10) +
  labs(x = "Genomic Position", y = "Individual", title = "Archaic Segments in a small\npart of Chromosome 10") +
  theme(aspect.ratio = .5,
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())
```

Since the segments do not overlap we have to somehow efficiently measure their degree of similarity, the most naïve method would be to index would be a distance metric calculated between binary vectors of archaic/modern state for each position in e.g. a chromosome. An intuitive similarity measure between such vectors would be the intersection over union, also called the Jaccard Index, both of these have a complementary dissimilarity measure:

$$d_\mathrm{J}(\mathbf{x},\mathbf{y})=d_{\mathrm{IoU}}(\mathbf{x},\mathbf{y})=1 - \frac{\sum_{i=0}^{|\mathbf{x}|}\mathbf{1}_{x_i = 1\;\land\; y_i = 1}}{\sum_{i=0}^{|\mathbf{x}|}\mathbf{1}_{x_i = 1\;\lor\; y_i = 1}},\quad |\mathbf{x}| = |\mathbf{y}|$$
This distance can be readily interpreted as 1 minus the proportion of shared archaic state out of the maximum possible given the two individuals in question.
This distance is chosen due to it's interpretability and since it can be efficiently calculated using bitwise boolean operations (much much faster than explicitly computing the intersections and union). However we will still expect this to be prohibitive due to the memory footprint of binary vectors the size of the human genome. We therefore opt to approximate the binary archaic state vectors by dividing the indices of the archaic fragments by a relatively large constant (400) and rounding it. By doing this we are able to reduce the memory usage by several orders of magnitude while not sacrificing much in terms of precision. 
It is however very important to consider the way in which the indices are rounded after division, to ensure that the calculated distances are unbiased and low-variance. This will be explored in the following section.

# Comparison of suggested methods for efficient unbiased approximation of $d_{\mathrm{IoU}}$
I suggest six rather straight-forward rounding methods:

1) Ceiling
2) Floor
3) Round
4) Random
5) Expand
6) Contract

the first three are perhabs the most naïve; "Ceiling", "Floor" and "Round". In these three methods we simply round both the start and end indices the same way: either up, down or to the closest integer. The next three methods are slightly more complicated. 

In the "Random" method I still use the same method on both the start and end index. First the number is split into it's integer, $x_Z$, and decimal, $X_R$, parts and then the decimal part is sampled as a Bernoulli variable, and the final rounded number, $X_{\mathrm{round}}$ is then the sum of these such that: $X_{\mathrm{round}}=X_Z+\mathrm{B}(1,X_R)$. 

The last two methods treat the start and end indices differently:
The "Expand" method <i>expands</i> the rounded intervals by rounding the start index down and the end index up. The "Contract" method <i>contracts</i> the rounded intervals by doing the opposite of the "Expand" method; rounding the start index up and the end index down. 

I evaluate these different methods by randomly selecting two individuals and extracting their archaic segments in chromosome 3 (arbitrarily). I then calculate $d_{\mathrm{IoU}}$ for increasingly downscaled representations (approximations) of the archaic segments:

\begin{figure}
  \includegraphics[width=\textwidth]{approxError_zoom.pdf}
\end{figure}

# Analyses

## Prepare data
Before doing analyses, I offset the genomic positions of the segments such that the indices in each chromosome start after the end of the previous chromosome 
```{r prepareArch}
all_chrom_range <- arch %>%
  group_by(chrom) %>% 
  summarize(
    start = min(start),
    end = max(end),
    .groups = "drop"
  ) %>% 
  arrange(chrom) %>% 
  mutate(
    length = end - start,
    offset = lag(cumsum(length), default = 0) #- first(length)
  )

if (nrow(all_chrom_range) == 1) {
  all_chrom_summary <- as.list(all_chrom_range[-1]) %>% 
    lapply(function(x) set_names(x, all_chrom_range$chrom))
} else {
  all_chrom_summary <- all_chrom_range %>% 
    summarize(across(!chrom, ~list(set_names(.x, chrom)))) %>% 
    as.list %>% 
    lapply(first)
}

all_chrom_range %>% 
  mutate(across(c(start, end), ~.x - start + 1 + offset)) %>% 
  mutate(chrom = as.integer(chrom)) %>%
  mutate(nchrom = lead(chrom),
         nstart = lead(start)) %>% 
  ggplot() +
  geom_segment(aes(chrom, start, xend = chrom, yend = end)) +
  geom_segment(aes(chrom, end, xend = nchrom, yend = nstart)) +
  scale_x_continuous(labels = levels(all_chrom_range$chrom), breaks = 1:length(levels(all_chrom_range$chrom)))


arch_approx <- arch %>% 
  group_by(chrom) %>%
  mutate(across(c(start, end), ~.x - 
                  all_chrom_summary$start[as.character(first(chrom))] + 
                  all_chrom_summary$offset[as.character(first(chrom))] + 
                  1)) %>%
  ungroup %>% 
  mutate(across(c(start, end), ~.x/30000),
         start = ceiling(start),
         end = floor(end)) %>%
  mutate(length = end - start) %>% 
  filter(length > 0)
```

I then combine all segments in each individual into a pseudo-class which is essentially a custom data structure, such that I can use custom-made functions that work on said data structure.
```{r preparePersons}
x_chrom_end_range <- arch_approx %>%
  pull(end) %>% 
  range

x_chrom_start_range <- arch_approx %>% 
  pull(start) %>% 
  range

x_chrom_min <- x_chrom_start_range[1]
x_chrom_max <- x_chrom_end_range[2] - x_chrom_min + 1

arch_approx <- arch_approx %>%
  mutate(across(c(start, end), ~.x - x_chrom_min + 1))

arch_persons <- arch_approx %>% 
  group_by(name, pop, country, region) %>% 
  summarize(
    prs = list(person(start, end, x_chrom_max)),
    .groups = "drop"
  ) %>% 
  mutate(prs = prs %>% 
           set_names(name))
```
Now that the data is prepared in a suitable data structure I can perform my analyses.


## Pairwise $d_\mathrm{IoU}$
I then move on to using the full pairwise distance matrix, this would not be feasible without the explained optimizations. However using the methods described this can be done in a matter of seconds-to-minutes.
```{r pairDIoU}
time_used <- system.time(
  all_dmat <- arch_persons %>%
              # slice_sample(n = 50) %>%
  person_pairwise_dist_df("prs", "name", implicit = F)
)
```

And the full pairwise $d_\mathrm{IoU}$ matrix is computed in only `r time_used[3]` seconds. The distance matrix is visualized below:

```{r allPairDMat, fig.width = 12, fig.height = 12}
### Create plot
skip_labels <- function(n) function(x) replace(x, which(!(1:length(x) %in% floor(seq(1, length(x), length.out = n)))), "")

prs_to_country <- all_dmat %>% 
  distinct(country_1, prs_1) %>% 
  {set_names(.$country_1, .$prs_1)}

label_prs_to_country <- function(prs) {
  country <- prs_to_country[prs] %>% 
    unname
  
  country_boundary_ind <- c(1, which(country[1:(length(country) - 1)] != country[2:length(country)]))
  
  country_center_ind <- country_boundary_ind + 
    (c(country_boundary_ind, length(country)) %>% 
       diff %>% 
       divide_by(2) %>% 
       ceiling)
  
  country[-country_center_ind] <- ""
  country
}

all_dmat_plt <- all_dmat %>% 
  # filter(country_1 == "Papua" & country_2 == "Papua") %>% 
  arrange(region_1, country_1, pop_1, prs_1) %>%  
  mutate(
    country_1 = factor(country_1, unique(country_1)) %>% 
      fct_shuffle,
    country_2 = factor(country_2, levels(country_1)),
    prs_1 = factor(prs_1, unique(prs_1)),
    prs_2 = factor(prs_2, levels(prs_1))
  ) %>% 
  mutate(iou = ifelse(prs_1 == prs_2, NA, iou)) %>% 
  ggplot(aes(prs_1, prs_2, fill = iou, color = iou)) +
  geom_tile() +
  scale_fill_viridis_c(#trans = "log10",
    option = "A",
    direction = -1,
    na.value = "gray75",
    labels = scales::label_percent(),
    name = "1 - IoU") +
  scale_colour_viridis_c(#trans = "log10",
    option = "A",
    direction = -1,
    na.value = "gray75",
    labels = scales::label_percent()) +
  new_scale_fill() +
  geom_tile(aes(x = -4.5, y = ifelse(as.integer(prs_1) == 1, prs_2, NA), fill = factor(as.integer(country_2) %% 2), color = after_scale(fill)),
            width = 10,
            show.legend = F) +
  geom_tile(aes(y = -4.5, 
                x = ifelse(as.integer(prs_2) == 1, prs_1, NA), 
                fill = factor(as.integer(country_1) %% 2), 
                color = after_scale(fill)),
            height = 10,
            show.legend = F) +
  scale_fill_manual(values = c("gray35", "gray85")) +
  scale_x_discrete(labels = label_prs_to_country, expand = expansion(0, c(10, 0))) +
  scale_y_discrete(labels = label_prs_to_country, expand = expansion(0, c(10, 0))) +
  coord_equal() +
  guides(colour = guide_none()) +
  theme(axis.ticks = element_blank(),
        axis.text.x = element_text(hjust = 1,
                                   angle = 90,
                                   vjust = .1),
        axis.text.y = element_text(vjust = .1),
        axis.text = element_text(size = 6),
        axis.title = element_blank(),
        legend.title = element_text(hjust = .5,
                                    size = 20),
        legend.text = element_text(size = 14),
        legend.key.width = unit(2, "lines"),
        legend.key.height = unit(4, "lines"))

# all_dmat_plt
ggsave("all_dmat.pdf", all_dmat_plt,
       device = cairo_pdf,
       width = 16, height = 16, dpi = 400, scale = .5)
# all_dmat_plt
```
\begin{figure}
  \includegraphics[width=\textwidth]{all_dmat.pdf}
\end{figure}


The distance matrix can be summarized for:

## Within population variation
The first analysis I perform is an investigation into the within-population shared archaic ancestry.
```{r withinPopDIoU}
lower_tri_base_width <- Vectorize(function(area) {
  if (is.na(area) | is.null(area)) return(NA)
  new_tri_area <- 0
  new_base <- 0
  while (new_tri_area < area) {
    new_base <- new_base + 1
    new_tri_area <- new_tri_area + new_base
  }
  new_base
}, USE.NAMES = F, SIMPLIFY = T)

within_pop_iou <- all_dmat %>% 
  filter(pop_1 == pop_2) %>% 
  mutate(
    prs_1 = factor(prs_1),
    prs_2 = factor(prs_2, levels(prs_1))
  ) %>% 
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  rename("region" = "region_1", "country" = "country_1", "pop" = "pop_1") %>% 
  group_by(pop) %>% 
  filter(n() > 2) %>% 
  mutate(n = ifelse(row_number() == 1, n(), NA),
         n = lower_tri_base_width(n) + 1) %>% 
  ungroup %>% 
  mutate(region = str_replace_all(region, "(?<!^)(?=[A-Z])", "-")) %>% 
  arrange(region, country, pop) %>% 
  mutate(across(c(country, pop), ~factor(.x, unique(.x)))) %>%
  ggplot(aes(iou, pop, fill = region, label = n)) +
  geom_violin(scale = "width",
              key_glyph = draw_key_point) +
  geom_text(aes(x = 1),
            hjust = 1,
            vjust = 1.1,
            fontface = "bold",
            family = "CMU Serif",
            size = 6) +
  scale_x_continuous(expand = expansion(0, c(0, 0)),
                     limits = 0:1,
                     labels = scales::label_percent()) +
  guides(fill = guide_legend(override.aes = list(shape = 21,
                                                 size = 10,
                                                 stroke = 1))) +
  scale_fill_brewer(palette = "Dark2") +
  labs(x = latex2exp::TeX("$d_{IoU}$"),
       y = NULL,
       fill = "Geographical\nRegion") +
  theme(legend.text = element_text(size = 14),
        axis.text.y = element_text(hjust = 0),
        axis.title.x = element_text(margin = margin(1, 0, 0, 0, "lines")),
        axis.ticks = element_blank(),
        title = element_text(size = 20),
        panel.grid.major.y = element_line(colour = "gray75", linewidth = .5, linetype = "dashed"))

ggsave("within_pop_iou.pdf", within_pop_iou,
       device = cairo_pdf,
       width = 5.5, height = 4, scale = 2.5)
# within_pop_iou
```
\begin{figure}
  \includegraphics[width=\textwidth]{within_pop_iou.pdf}
\end{figure}

## Summarized for regions
```{r allPairRegionSum}
region_dmat <- all_dmat %>% 
  mutate(prs_1 = factor(prs_1),
         prs_2 = factor(prs_2, levels = levels(prs_1))) %>% 
  filter(as.integer(prs_1) < as.integer(prs_2)) %>% 
  group_by(same_region = region_1 == region_2, region_1, region_2) %>% 
  summarize(
    iou = mean(iou),
    .groups = "drop"
  ) %>%
  mutate(across(matches("^region"), ~str_replace_all(.x, "(?<!^)(?=[A-Z])", "-\n"))) %>% 
  ggplot(aes(region_1, region_2, fill = iou)) +
  geom_tile(aes(color = after_scale(fill)),
            linewidth = 0) +
  scale_fill_viridis_c(option = "A",
                       direction = -1) +
  coord_equal(expand = F) +
  labs(fill = "1 - IoU") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank(),
        legend.title = element_text(hjust = .5,
                                    size = 20),
        legend.text = element_text(size = 14),
        legend.key.width = unit(2, "lines"),
        legend.key.height = unit(4, "lines"))

ggsave("region_dmat.pdf", region_dmat,
       device = cairo_pdf,
       width = 4, height = 4, scale = 2.5)
# region_dmat
```
\begin{figure}
  \includegraphics[width=\textwidth]{region_dmat.pdf}
\end{figure}
and:

## Summarized for countries
```{r allPairCountrySum}
country_dmat <- all_dmat %>% 
  arrange(region_1) %>% 
  mutate(prs_1 = factor(prs_1),
         prs_2 = factor(prs_2, levels = levels(prs_1)),
         country_1 = factor(country_1, unique(country_1)),
         country_2 = factor(country_2, levels(country_1))) %>%
  group_by(same_country = country_1 == country_2, country_1, country_2) %>% 
  summarize(
    iou = mean(iou[prs_1 != prs_2]),
    .groups = "drop"
  ) %>% 
  # mutate(across(matches("^country"), ~str_replace_all(.x, "(?<!^)(?=[A-Z])", "-\n"))) %>% 
  complete(country_1, country_2, fill = list(iou = NA)) %>% 
  ggplot(aes(country_1, country_2, fill = iou)) +
  geom_tile(aes(color = after_scale(fill)),
            linewidth = 0) +
  scale_fill_viridis_c(option = "A",
                       na.value = "gray75",
                       direction = -1) +
  coord_equal(expand = F) +
  labs(fill = "1 - IoU") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 1),
        axis.title = element_blank(),
        legend.title = element_text(hjust = .5,
                                    size = 20),
        legend.text = element_text(size = 14),
        legend.key.width = unit(2, "lines"),
        legend.key.height = unit(4, "lines"))

ggsave("country_dmat.pdf", country_dmat,
       device = cairo_pdf,
       width = 4, height = 4, scale = 2.5)
# country_dmat
```
\begin{figure}
  \includegraphics[width=\textwidth]{country_dmat.pdf}
\end{figure}

And also used for post-hoc hierarchical clustering:

## Archaic state "phylogeny"
```{r allPairHierClust, fig.width = 12, fig.height = 12}
arch_meta <- arch_persons %>% 
  select(name, pop, country, region) %>% 
  arrange(region) %>% 
  mutate(country = factor(country, unique(country)))

all_t_dmat <- all_dmat %>% 
  # filter(region_1 != "Melanesia" & region_2 != "Melanesia") %>% 
  arrange(country_1, country_2) %>% 
  mutate(
    prs_1 = factor(prs_1, unique(prs_1)),
    prs_2 = factor(prs_2, levels(prs_1))
  ) %>% 
  # filter(region_1 != "Melanesia" & region_2 != "Melanesia") %>% 
  select(prs_1, prs_2, iou) %>%
  pivot_wider(id_cols = prs_1, names_from = prs_2, values_from = iou) %>%
  set_rownames(.$prs_1) %>%
  select(!prs_1) %>% 
  as.matrix %>% 
  as.dist

all_tree <- all_t_dmat %>% 
  # ape::nj()
  hclust("ward.D2")

all_cluster <- cutree(all_tree, 6) %>% 
  {
    tibble(label = names(.),
           cluster = unname(.))
  }

hier_cluster_dmat <- as_tbl_graph(all_tree) %>% 
  left_join(all_cluster) %>%
  left_join(arch_meta, by = c(label = "name")) %>% 
  ggraph() +
  geom_edge_elbow(
    position = position_nudge(y = .1)
  ) +
  geom_node_tile(aes(fill = factor(cluster), width = leaf),
                 height = .05,
                 color = "transparent") +
  scale_fill_brewer(palette = "Set1",
                    name = "Post-Hoc Cluster") +
  new_scale_fill() +
  geom_node_tile(aes(fill = country, width = leaf),
                 height = .05,
                 color = "transparent",
                 position = position_nudge(y = .1)) +
  scale_fill_discrete(name = "Country") 

ggsave("hier_cluster_dmat.pdf", hier_cluster_dmat,
       device = cairo_pdf,
       width = 7, height = 6, scale = 2.5)
# theme(legend.position = "bottom")
```
\begin{figure}
  \includegraphics[width=\textwidth]{hier_cluster_dmat.pdf}
\end{figure}

## Low-dimensional ordination of archaic state dissimilarity
The pairwise distance matrix can also be ordinated using e.g. Principal Coordinate Analysis:
```{r allPairOrd}
ord_data <- all_t_dmat %>% 
  # umap() %>%
  cmdscale(k = 4) %>%
  as.data.frame() %>%
  set_colnames(paste0("PCoA", 1:ncol(.))) %>%
  rownames_to_column("prs") %>%
  as_tibble() %>% 
  left_join(arch_meta, by = c(prs = "name")) %>% 
  group_by(country) %>% 
  mutate(label_country = ifelse(row_number() == 1, country, NA),
         label_country = levels(country)[label_country]) %>% 
  ungroup

ord_plt <- ord_data %>% 
  ggplot(aes(.panel_x, .panel_y, color = region)) +
  geom_point(size = 2,
             alpha = .5,
             shape = 16) +
  geom_autodensity(aes(fill = after_scale(color)),
                   linewidth = .75,
                   alpha = .25) +
  stat_density2d(aes(group = "1", fill = after_stat(ndensity)),
                 colour = "transparent",
                 contour = F,
                 adjust = c(2,2),
                 geom = "raster") +
  facet_matrix(vars(contains("PCoA")),
               layer.diag = 2,
               layer.lower = 3,
               shrink = F) +
  scale_x_continuous(limits = c(-.5, .5), expand = expansion()) +
  scale_y_continuous(limits = c(-.5, .5), expand = expansion()) +
  scale_color_brewer(palette = "Set1") +
  scale_fill_distiller(trans = "identity",
                       palette = "Oranges",
                       direction = 1,
                       guide = "none") +
  labs(color = "Geographical\nRegion") +
  coord_cartesian(expand = F) +
  guides(color = guide_legend(override.aes = list(alpha = 1,
                                                  size = 5))) +
  theme(panel.border = element_rect(fill = "transparent"))

ggsave("ord_plt.pdf", ord_plt,
       device = cairo_pdf,
       width = 7, height = 6, scale = 2)
```
\begin{figure}
  \includegraphics[width=\textwidth]{ord_plt.pdf}
\end{figure}


## EPAS1
```{r}
# filter(chrom == "2" & between(start, 46293667-10^6, 46386697+10^6) & between(end, 46293667-10^6, 46386697+10^6))
```


# Correlation between total archaic length and shared length
```{r lenDIoURelationship}
library(mgcViz)
library(metR)

len_iou_2d_dat <- all_dmat %>% 
  rename_with(function(x) str_replace(x, "prs", "name")) %>% 
  left_join(arch_persons %>% 
              select(name, prs), by = c(name_1 = "name")) %>% 
  rename("prs_1" = "prs") %>% 
  left_join(arch_persons %>% 
              select(name, prs), by = c(name_2 = "name")) %>% 
  rename("prs_2" = "prs") %>% 
  mutate(
    name_1 = factor(name_1),
    name_2 = factor(name_2, levels(name_1))
  ) %>% 
  filter(name_1 != name_2) %>% 
  # filter(as.integer(name_1) > as.integer(name_2)) %>% 
  mutate(
    across(contains("prs"), ~map_int(.x, function(x) {
      sum(x$end - x$start)
    })),
    across(where(is.character), factor)
    # prs_2 = cut_width(prs_2, 500, 250, dig.lab = 50)
  )

pred_grid <- expand_grid(prs_1 = 10^seq(3, 5, .05),
                         prs_2 = 10^seq(3, 5, .05))#unique(len_iou_2d_dat$prs_2))

len_iou_plt <- len_iou_2d_dat %>% 
  bam(iou ~ s(prs_1, prs_2, k = 100) + s(region_1, region_2, bs = "re"), data = .,
      family = "quasibinomial", discrete = T) %>%
  # getViz() %>% 
  # check.gamViz()
  predict(pred_grid %>% 
            # filter(as.character(prs_2) %in% levels(len_iou_2d_dat$prs_2)) %>% 
            mutate(region_1 = "WestEurasia",
                   region_2 = "Melanesia"), 
          exclude = "s(region_1)",
          type = "response") %>% 
  {
    mutate(pred_grid, pred = .)
  } %>% 
  ggplot(aes(prs_1, prs_2)) +
  geom_tile(aes(fill = pred)) +
  geom_rug(data = len_iou_2d_dat %>% 
             mutate(across(c(prs_1, prs_2), ~1000*round(.x/1000))) %>% 
             count(prs_1, prs_2),
           length = unit(0.015, "npc"),
           alpha = .1,
           aes(linewidth = n)) +
  scale_x_log10(labels = prettify_scientific,
                n.breaks = 8) +
  scale_y_log10(labels = prettify_scientific,
                n.breaks = 8) +
  scale_fill_viridis_c(option = "A") +
  coord_cartesian(expand = F) +
  labs(x = "Person X", y = "Person Y", title = "Relationship between IoU and total amount of\n archaic heritage in the in the compared persons", fill = "1 - IoU",
       caption = latex2exp::TeX("Only different pairs of individuals are included i.e. $d_{IoU}(X_i, Y_j)$ for $i > j$")) +
  theme(
    plot.caption = element_text(hjust = 0)
  )

ggsave("len_iou.pdf", len_iou_plt,
       device = cairo_pdf,
       width = 7, height = 6, scale = 2)
```
\begin{figure}
  \includegraphics[width=\textwidth]{len_iou.pdf}
\end{figure}

